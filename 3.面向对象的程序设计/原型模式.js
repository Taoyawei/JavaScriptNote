/*
原型模式：
1.每个函数在创建时，都会创建一个属性，prototype，这想当与一个指针，指向的就是
圆形对象，prototype，而这个原型对象中开始只有一个默认属性，constructor，而
prototype.constructor就是指向创建的函数

2.向原型对象中添加属性，函数名加上prototype加属性名=值，当使用var 新名称=new 原函数（）
这种新名称就相当于复制了一个指针，也指向原函数的原型对象，这new出来的所有新的对象都
指向原型对象，实现资源共享，这就是原型模式的精华

3.我们无法直接访问到prototype，但是我们可以用isprototypeOf()方法来判断你的心对象是
否指向原型对象，如果是就true

4.我们可以有Object.getPrototypeOf()来获取你要的对象与原型对象比较，如果相等就返回true

5.我们new出来的对象指向原型对象实现共享，但我们访问一个属性时，先在自己对象中找，
如果没有再去原型对象中找，那么就有问题了，怎么判断你的属性从哪个对象中来的，用
hasOwnProperty()方法，如果是实例对象中的就返回true

6.in的使用：in可以确定该属性能不能被这个对象获取到，能就返回true，不论是实例对象中
或都是prototype中的

7.我们前面直接prototype中加属相，一个一个的太慢了，课直接加多个，如下：
			person.prototype({
					name:xx,
					age:xx,....
			});
，这样的优点：就是快，操作方便
	缺点：这相当于重写了prototype对象，其中不再有constructor属性，可以加上
	但是在此之前创建的实例不能访问重写后的。


	总结：一般构造模式和原型模式是结合着用，构造模式存放实例属性，二prototype中存放
	共有的属性和方法
*/